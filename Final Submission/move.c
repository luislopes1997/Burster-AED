/********************************************************************
 * move.c -- Move Data Structure                      		        *
 ********************************************************************
 * Project: AED project - Burster                    				*
 *                                                                  *
 * Authors: Lu√≠s Lopes (ist425416), Miguel Freire (ist425445)  		*
 ********************************************************************/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "defs.h"
#include "cluster.h"
#include "util.h"
#include "matrix.h"
#include "move.h"

/**
 * Initializes first move
 * @param firstMove  pointer to first move
 * @param puzzleFile file with puzzle problem
 * @param rows       number of puzzle's rows
 * @param cols       number of puzzle's cols
 */
void initMove(Move *firstMove, FILE *puzzleFile, int rows, int cols) {
	int n = 0;
	readMatrixFromFile(firstMove->puzzle, puzzleFile, rows, cols);
	firstMove->clusters = getPuzzleClusters(firstMove->puzzle, firstMove->clusters ,&n, &firstMove->maxScore);
	firstMove->numClusters = n;

}

/**
 * Creates a new move
 * @param  rows number of puzzle's rows
 * @param  cols number of puzzle's cols
 * @return      pointer to the new move
 */
Move *newMove(int rows, int cols) {
	Move *new;
	new = (Move *) smalloc(sizeof(Move));
	new->puzzle = newMatrix(rows, cols);
	new->clusters = NULL;
	new->numClusters = 0;
	new->score = 0;
	new->availableCluster = 0;
	new->maxScore = 0;

	return new;
}

/**
 * Free moves and every sub-datastructure
 * @param moves    Array of moves
 * @param numMoves Number of moves
 */
void freeMoves(Move **moves, int numMoves) {
	int i;

	for(i = 0; i < numMoves; i++) {
		freeMatrix(moves[i]->puzzle);
		if(moves[i]->clusters != NULL) 
		freeClusterGroup(moves[i]->clusters);
		free(moves[i]);
	}
	free(moves);
}

/**
 * DFS Backtracking algorithm to find the solution of a puzzle problem
 * @param moves     Array of moves
 * @param k         index of the array move (current move)
 * @param objective objective of the problem
 * @param numMoves  var to save number of moves
 * @param path      path to save the path of moves to the solution
 * @param found     boolean to know if the solution was found
 */
void findSolution(Move **moves, int k, int objective, int *numMoves,Path *path, int *found) {
	int score;
	if(objective > 0 && moves[k]->score >= objective && moves[k]->numClusters == 0) { 
	/*If we are in variant 2 and we passed desirable score than set found control variable to true*/
		*found = 1;
	}
	if(moves[k]->numClusters == 0) return; /*If there are no more moves available to do backtrack*/
	else {
		(*numMoves)++;
		while(moves[k]->numClusters != 0) { /*While there are available moves*/

			/*Do the move*/

			/*Clone the matrix*/
			cloneMatrix(moves[k]->puzzle, moves[k+1]->puzzle); 
			
			/*clone score*/
			moves[k+1]->score = moves[k]->score; 
			
			/*Do the move (remove cluster)*/
			moves[k]->clusters = removeCluster(moves[k+1]->puzzle, moves[k]->clusters, &path[k], &score); 
			
			/*Update move score*/
			moves[k+1]->score += score; 

			/*Get puzzle clusters*/
			moves[k+1]->clusters = getPuzzleClusters(moves[k+1]->puzzle, moves[k+1]->clusters, &moves[k+1]->numClusters, &moves[k+1]->maxScore);
			
			/*Call find solution on new matrix generated by this move*/
			findSolution(moves, k+1, objective, numMoves, path, found);

			/*If variant is -1 or variant 2 and the objective has been reached than end deep search*/
			if(objective == -1 || objective == 0) return;
			if(found) return;
		}

		return;
	}
}
